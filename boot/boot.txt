[BITS 16]
[ORG 0x7C00]
jmp _start
[global _start]
_start:
cli
 xor ax, ax
 mov ds, ax
 mov es, ax
 mov fs, ax
 mov gs, ax
 mov ax, 0x02d0
 mov ss, ax
 xor ax, ax
 mov sp, 0x4eff
sti
 jmp 0h: $ + 5
 mov BYTE[BootDrive], dl
 mov si, BootLoadingMsg
 call func_biosPrint
 call func_EnableA20
 mov dl, [BootDrive]
 call func_ResetDisk
 mov eax, [PVDBufAddress]
 mov es, eax
 xor edi, edi
 call func_ReadPrimaryVolumeDescriptor
 mov eax, [PVDBufAddress]
 mov es, eax
 xor edi, edi
 call func_LocateKernelImage
 call func_LoadKernel
 call func_DiscoverMemory
 call func_PrepareGDT
 call func_EnableProtectedModeAndJmpKernel
 cli
 hlt
bootFailure:
 mov si, BootFailureMsg
 call func_biosPrint
bootloaderEnd:
 cli
 hlt
%line 90+1 ./screen.asm
func_biosPrint:
 pushad
loop_biosPrint:
 lodsb
 cmp al, 0
 je end_biosPrint
 mov ah, 0x0e
 int 0x10
 jmp loop_biosPrint
end_biosPrint:
 popad
 ret
func_biosClearScreen:
 xor ax, ax
 mov al, 02h
 int 10h
 ret
func_printf:
 pushad
 mov bx, 0xb800
 mov es, bx
loop_printf:
 lodsb
 cmp al, 0
 je end_printf
 mov ah, whiteOnBlackConst
 mov bx, [currentCursorPosition]
 mov [es:bx], ax
 inc bx
 inc bx
 mov [currentCursorPosition], bx
 jmp loop_printf
end_printf:
 popad
 ret
func_EnableA20:
 pushad
 cli
 mov cx, 0
checkIfEnabled:
 clc
 call func_testA20
 jnz EnableA20End
EnableA20:
 cmp cx, 0
 je BiosEnable
 cmp cx, 1
 je KeyboardControllerEnable
 cmp cx, 2
 je FastGateEnable
 jmp bootFailure
BiosEnable:
 inc cx
 clc
 call func_biosEnableA20
 jc EnableA20
 jmp checkIfEnabled
KeyboardControllerEnable:
 inc cx
 call func_keyboardControllerEnableA20
 jmp checkIfEnabled
FastGateEnable:
 inc cx
 in al, 0x92
 test al, 2
 jnz checkIfEnabled
 or al, 2
 and al, 0xFE
 out 0x92, al
 jmp checkIfEnabled
EnableA20End:
 sti
 popad
 ret
func_testA20:
 pushad
 push ds
 push es
 xor ax, ax
 mov es, ax
 not ax
 mov ds, ax
 mov di, 0x0500
 mov si, 0x0510
 mov al, byte [es:di]
 push ax
 mov al, byte [ds:si]
 push ax
 mov byte [es:di], 0x00
 mov byte [ds:si], 0xFF
 cmp byte [es:di], 0xFF
 pop ax
 mov byte [ds:si], al
 pop ax
 mov byte [es:di], al
 pop es
 pop ds
 popad
 ret
func_biosEnableA20:
 pushad
 mov ax, 2403h
 int 15h
 jb biosError
 cmp ah, 0
 jnz biosError
 mov ax, 2402h
 int 15h
 jb biosError
 cmp ah, 0
 jnz biosError
 cmp al, 1
 jz biosEnableEnd
 mov ax, 2401h
 int 15h
 jb biosError
 cmp ah, 0
 jnz biosError
 jmp biosEnableEnd
biosError:
 stc
biosEnableEnd:
 popad
 ret



func_keyboardControllerEnableA20:
 pushad

 call func_a20WaitAl2
 mov al, 0xad
 out 0x64, al

 call func_a20WaitAl2
 mov al, 0xd0
 out 0x64, al

 call func_a20WaitAl1
 in al, 0x60
 push eax

 call func_a20WaitAl2
 mov al, 0xd1
 out 0x64, al

 call func_a20WaitAl2
 pop eax
 or al, 2
 out 0x60, al

 call func_a20WaitAl2
 mov al, 0xae
 out 0x64, al

 call func_a20WaitAl2
controllerEnd:
 popad
 ret






func_a20WaitAl2:
 in al, 0x64
 test al, 2
 jnz func_a20WaitAl2
 ret






func_a20WaitAl1:
 in al,0x64
 test al,1
 jz func_a20WaitAl1
 ret

%line 100+1 ./isoUtilities.asm
func_ReadPrimaryVolumeDescriptor:
rpvd_read:
 pushad


 mov ebx, 10h
 mov cx, 1
 call func_ReadISOSector

 mov al, BYTE[es:di]
 cmp al, 1
 je rpvd_ret
 jmp bootFailure
rpvd_ret:
 popad
 ret






func_ResetDisk:
 mov cx, 3
rd_loop_trials:
 mov ah, 0
 int 13h
 jc rd_ResetFail
 ret
rd_ResetFail:
 dec cx
 cmp cx, 0
 je bootFailure
 jmp rd_loop_trials









func_ReadISOSector:

 pushad

 mov ax, es
 mov WORD[dapNumSectors], cx
 mov WORD[dapBufferOffset], di
 mov WORD[dapBufferSegment], ax
 mov DWORD[dapSectorNumL], ebx
 mov DWORD[dapSectorNumH], 0

 mov ah, 0x42
 mov dl, BYTE[BootDrive]
 mov si, DAP
 int 13h
 jc bootFailure
 popad
 ret
%line 96+1 ./kernelLoad.asm
func_LocateKernelImage:
 pushad




 mov ebx, [es:di + 158]



 xor di, di
 mov ax, [BLBufPointer]
 mov es, ax
 mov cx, 1
 call func_ReadISOSector

 xor di, di
 mov bx, di


loopLocateKernelFile:
 xor edx, edx
 mov dl, BYTE [es:bx]
 xor ecx, ecx
 mov cl, BYTE [es:bx + 32]
 add di, 33
 mov si, KernelName
cmpStr:
 cmp cx, 0
 je fileFound
 dec cx
 cld
 cmpsb
 jne nextEntry
 jmp cmpStr
nextEntry:
 add bx, dx
 mov di, bx
 jmp loopLocateKernelFile
fileFound:
 mov eax, DWORD [es:bx + 2]
 mov [KernelLBA], eax
 mov eax, DWORD [es:bx + 10]
 mov [KernelLength], eax

 popad
 ret







func_LoadKernel:
 pushad

 xor eax, eax
 mov ebx, eax
 mov ecx, eax

 mov eax, [KernelLength]
 add eax, 0x0800
 mov bx, 0x0800
 div bx

 mov cl, al
 mov ax, 0x0840
 mov es, eax
 xor di, di
 mov ebx, [KernelLBA]
 call func_ReadISOSector
 popad
 ret
%line 98+1 ./memory.asm
func_DiscoverMemory:
 pusha


 mov ax, [MLTBufAddress]
 mov es, ax
 xor di, di
 xor ebx, ebx
 mov di, 4

NextEntry:
 mov eax, [MemRegionsCount]
 inc eax
 mov [MemRegionsCount], eax

 mov edx, 0x534D4150
 mov eax, 0xE820
 mov ecx, 0x18
 int 15h
 jc MemDiscoveryErr
 cmp bx, 0
 je MemDiscoveryEnd

 add di, cx
 jmp NextEntry

MemDiscoveryErr:
 popa
 mov si, MemDiscoveryFailureMsg
 call func_biosPrint
 jmp bootFailure

MemDiscoveryEnd:

 mov ax, [MLTBufAddress]
 mov es, ax
 xor di, di
 mov si, MemRegionsCount
 movsd


 mov ah, [MemRegionsCount]
 mov [BootHDRAddress], ah
 mov eax, MLTBufAddress
 mov [BootHDRAddress + 1], eax

 popa
 ret
%line 98+1 ./pci.asm
func_DiscoverPCI:

 pusha


 mov ax, 0xb101
 xor edi, edi
 int 0x1a


 jc PCINotInstalled

 cmp ah, 0h
 jne PCINotInstalled


 mov bl, 1
 mov byte [BootHDRAddress + 9], bl


 bt al, 0
 jc PCIMech1


 bt al, 1
 jc PCIMech2



PCIMech1:
 mov bl, 1
 mov edx, BootHDRAddress
 mov byte [edx + 10], bl
 jmp PCIEnd

PCIMech2:
 mov bl, 2
 mov edx, BootHDRAddress
 mov byte [edx + 10], bl
 jmp PCIEnd

PCINotInstalled:
 popa
 mov si, PCIErrorMsg
 call func_biosPrint
 jmp bootFailure

PCIEnd:

 popa
 ret
%line 91+1 ./gdt.asm
func_PrepareGDT:
 pushad

 cli
 lgdt [GDT]

 popad
 ret
%line 92+1 ./protectedMode.asm
func_EnableProtectedModeAndJmpKernel:




 mov eax, cr0
 or eax, 0x1
 mov cr0, eax







 mov eax, 10h
 mov ds, eax
 mov fs, eax
 mov gs, eax
 mov ss, eax
 mov es, eax
 mov esp, 0x3fffff



 jmp 8h:0x8400
%line 94+1 bootloader.asm
BootDrive: db 0
BootFailureMsg: db "Booting sequence failed", 0
MemDiscoveryFailureMsg: db "Memory discover failed", 0
BootLoadingMsg: db "loading QBeOS...", 0
PCIErrorMsg: db "Couldn't discover PCI", 0
BytesPerSector: dw 0


KernelName: db "KERNEL.IMG", 0x3b, 0x31
KernelLBA: dd 0
KernelLength: dd 0


PVDBufAddress: dw 0x0050


BLBufPointer: dw 0x00d0


MLTBufAddress: dw 0x7000
MemRegionsCount: dd 0
BootHDRAddress: dw 0x7800


gdtData:
 dd 0x0000
 dd 0x0000

 dw 0xFFFF
 dw 0x0000
 DB 0x00
 DB 10011010b
 DB 11001111b
 DB 0x00

 dw 0xFFFF
 dw 0x0000
 DB 0x00
 DB 10010010b
 DB 11001111b
 DB 0x00
gdtEnd:
GDT:
 dw gdtEnd - gdtData - 1
 dd gdtData



DAP: db 10h
 db 0
dapNumSectors: dw 0
dapBufferOffset: dw 0
dapBufferSegment: dw 0
dapSectorNumL: dd 0
dapSectorNumH: dd 0


currentCursorPosition: db 0
whiteOnBlackConst: equ 0x0f
rowsLimit: equ 80
colsLimit: equ 25


%line 160+1 bootloader.asm


TIMES 2046 - ($ - $$) db 0
dw 0xaa55
